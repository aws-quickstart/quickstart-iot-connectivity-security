AWSTemplateFormatVersion: 2010-09-09
Description: Creates an amplify app (qs-1s0ipp9io)
Metadata:
  QuickStartDocumentation:
    EntrypointName: "Launch into a new VPC"
    Order: 1
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: "Name of project"
      Parameters:
        - ProjectName
    - Label:
        default: "ID of certificate authority"
      Parameters:
        - CACertificateID
    - Label:
        default: AWS Quick Start configuration
      Parameters:
        - QSS3BucketName
        - QSS3KeyPrefix
    ParameterLabels:
      ProjectName:
        default: Project Name
      CACertificateID:
        default: "ID of certificate authority"
      QSS3BucketName:
        default: AWS Quick Start Bucket
      QSS3KeyPrefix:
        default: AWS Quick Start Bucket Prefix
Parameters:
  ProjectName:
    Default: iotquickstart
    Type: String
    AllowedPattern: "[a-zA-Z0-9]*"
    ConstraintDescription: Must contain only alphanumeric characters.
  CACertificateID:
    Default: abcd
    Type: String
# Quick Start configuration
  QSS3BucketName:
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    ConstraintDescription: Quick Start bucket name can include numbers, lowercase
      letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Default: aws-quickstart
    Description: S3 bucket name for the Quick Start assets. Quick Start bucket name
      can include numbers, lowercase letters, uppercase letters, and hyphens (-).
      It cannot start or end with a hyphen (-).
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/]*$
    ConstraintDescription: Quick Start key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/).
    Default: quickstart-iot-connectivity-security/
    Description: S3 key prefix for the Quick Start assets. Quick Start key prefix
      can include numbers, lowercase letters, uppercase letters, hyphens (-), and
      forward slash (/).
    Type: String
Mappings:
  Constants:
    Value: 
      BranchName: main
      ProjectRepoKey: zip/repo.zip
Resources:
  LambdaGetRepo:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'CreateCodeCommitRepo${ProjectName}'
      Environment: 
        Variables:
          ZIP_KEY: !FindInMap [Constants, Value, ProjectRepoKey]
          REPO_PREFIX: "source/"
          QS_BUCKET: !Ref QSS3BucketName
          QS_BUCKET_PREFIX: !Ref QSS3KeyPrefix
          # These variables are references in amplify parameters.json files
          VARIABLES: !Sub
            - "ResourceTag:${resourceTag},Active:Active,Inactive:Inactive,Troubleshooting:Troubleshooting,Quarantine:Quarantine,CACertificateID:${CACertificateID}"
            - resourceTag: !Ref ProjectName
              CACertificateID: !Ref CACertificateID
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleGetRepo.Arn
      Runtime: python3.8
      Timeout: 300
      Code:      
        ZipFile: |
          import boto3
          import os
          import cfnresponse
          import io
          from io import BytesIO
          import zipfile
          from zipfile import ZipFile, ZIP_DEFLATED
          
          def handler(event, context):
              responseData = {}
              try:
                  print(event)
                  print(context)
                  result = cfnresponse.FAILED
                  if event['RequestType'] == 'Create':
                      s3Client = boto3.client('s3')
                      bucket = os.environ["QS_BUCKET"]
                      prefix = os.environ["QS_BUCKET_PREFIX"] + os.environ["REPO_PREFIX"]
                      zipKey = os.environ["QS_BUCKET_PREFIX"] + os.environ["ZIP_KEY"]
                      varArray = os.environ['VARIABLES'].split(",")
                      print(bucket)
                      print(prefix)
                      files = s3Client.list_objects_v2(
                          Bucket=bucket,
                          Prefix=prefix
                      )
                      print(files)
                      allFiles=files["Contents"]
              
                      mem_zip = BytesIO()
                      with ZipFile(mem_zip, mode="w", compression=ZIP_DEFLATED) as client:
                          for file in allFiles:
                              fileObject = s3Client.get_object(
                                  Bucket=bucket,
                                  Key=file["Key"]
                              )
                              newLocation=file["Key"].split(prefix,1)[1]
                              fileData=fileObject["Body"].read() 
                              if "parameters.json" in file["Key"]:
                                  fileString = fileData.decode('utf-8')
                                  for var in varArray:
                                      keyValue = var.split(":")
                                      fileString = fileString.replace("$"+keyValue[0],keyValue[1])
                                  fileData = fileString.encode('utf-8')
                              client.writestr(newLocation, fileData)
                      mem_zip.seek(0)
                      s3Client.upload_fileobj(mem_zip, bucket, zipKey)
                      result = cfnresponse.SUCCESS
                  else:
                      result = cfnresponse.SUCCESS
              except Exception as e:
                  print('error', e)   
              cfnresponse.send(event, context, result, {})
  LambdaExecutionRoleGetRepo:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'lambda-execution-role-get-repo-${ProjectName}'
      ManagedPolicyArns:
          - !Sub "arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement: 
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
  LambdaexecutionpolicyGetRepo:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyName: !Sub 'lambda-execution-policy-get-repo-${ProjectName}'
      Roles: 
        - !Ref LambdaExecutionRoleGetRepo
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub
              - "arn:${AWS::Partition}:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*"
              - region: !Ref "AWS::Region"
                account: !Ref "AWS::AccountId"
                lambda: !Ref LambdaGetRepo 
  SetupRepoCustomResource:
    DependsOn: [LambdaexecutionpolicyGetRepo]
    Type: Custom::CreateRepo
    Properties:
      ServiceToken: !GetAtt LambdaGetRepo.Arn
  CodeCommitRepo:
    Type: AWS::CodeCommit::Repository
    DependsOn: [SetupRepoCustomResource]
    Properties: 
      Code: 
        S3:
          Bucket: !Ref QSS3BucketName
          Key: 
            Fn::Sub:
              - "${prefix}${key}"
              - prefix: !Ref QSS3KeyPrefix
                key: !FindInMap [Constants, Value, ProjectRepoKey]
      RepositoryDescription: "IoT quickstart app"
      RepositoryName: !Ref ProjectName
  AmplifyRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
          - !Sub "arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - amplify.amazonaws.com
            Action:
              - sts:AssumeRole
  
  AmplifyApp:
    Type: AWS::Amplify::App
    Properties: 
      Description: "IoT quickstart app"
      IAMServiceRole: !GetAtt AmplifyRole.Arn
      EnvironmentVariables: 
        - Name: ResourceTag
          Value: !Ref ProjectName
      Name: !Ref ProjectName
      Repository: !GetAtt CodeCommitRepo.CloneUrlHttp
  AmplifyBranch:
    Type: AWS::Amplify::Branch
    Properties:
      BranchName: !FindInMap [Constants, Value, BranchName]
      AppId: !GetAtt AmplifyApp.AppId
      Description: Main Branch
      EnableAutoBuild: true
  LambdaDeployAmplifyApp:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'DeployAmplifyApp${ProjectName}'
      Environment: 
        Variables:
          APP_ID: !GetAtt AmplifyApp.AppId
          BRANCH_NAME: !FindInMap [Constants, Value, BranchName]
          RESOURCE_TIMEOUT_MIN: '30' 
          SELF_INVOKE_TIME_MIN: '10'
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRoleDeployApp.Arn
      Runtime: python3.8
      Timeout: 900
      Code:      
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import os
          import time
          
          
          amplifyPollTimeSec = 20
          
          execution = 'executionNumber'
          jobSummaryId = 'jobSummaryId'
          resourceStartTime = 'resourceStartTime'
          appId = os.environ['APP_ID']
          branchName = os.environ['BRANCH_NAME']
          functionName = os.environ['AWS_LAMBDA_FUNCTION_NAME']
          resourceTimeoutMin = os.environ['RESOURCE_TIMEOUT_MIN']
          selfInvokeTimeMin = os.environ['SELF_INVOKE_TIME_MIN']
          
          def handler(event, context):
              try:
                  print(event)
                  print(context)
                  result = cfnresponse.FAILED
                  client = boto3.client('amplify')
                  startTime = time.time()
                  
                  if event['RequestType'] == 'Create':    
                      firstIteration = False
                      if execution not in event:
                          event[execution] = 1
                          event[resourceStartTime] = startTime
                          firstIteration = True
                      
                      if firstIteration:
                          startJob=client.start_job(
                            appId=appId,
                            branchName=branchName,
                            jobType='RELEASE'
                          )
                          event['jobSummaryId']=startJob['jobSummary']['jobId']
                  
                      jobInProgress=True
                      
                      while jobInProgress:
                          time.sleep(amplifyPollTimeSec)
                          job=client.get_job(
                              appId=appId,
                              branchName=branchName,
                              jobId=event['jobSummaryId']
                          )
                          status=job['job']['summary']['status']
                          print(status)
                          
                          timeNow=time.time()
                          if status == "SUCCEED":
                              jobInProgress=False
                              result = cfnresponse.SUCCESS
                          elif status == "FAILED" or status == "CANCELLING" or status == "CANCELLED":
                              jobInProgress=False
                              print('Amplify failed to deploy')
                          elif (timeNow - startTime) > (int(selfInvokeTimeMin)*60):
                              jobInProgress=False
                              if (timeNow-event[resourceStartTime]) > (int(resourceTimeoutMin)*60):
                                  print('resource Timeout')
                              else:
                                  event[execution]  = event[execution] + 1
                                  jobInProgress=False
                                  print('self invoke')
                                  lambdaClient = boto3.client('lambda')
                                  lambdaClient.invoke(
                                      FunctionName=functionName,
                                      InvocationType='Event',
                                      Payload=bytes(json.dumps(event), encoding='utf8')
                                  )
                                  print('self invoke success')
                                  return
                  elif event['RequestType'] == 'Delete':
                      firstIteration = False
                      if execution not in event:
                          event[execution] = 1
                          event[resourceStartTime] = startTime
                          firstIteration = True
                      backend = client.get_backend_environment(
                          appId=appId,
                          environmentName=branchName
                      )
                      stackName = backend['backendEnvironment']['stackName']
                      cfnclient = boto3.client('cloudformation')
                      stackInfo = cfnclient.describe_stacks(
                          StackName=stackName
                      )
                      stackId=stackInfo['Stacks'][0]['StackId']
                      
                      if firstIteration:                   
                          cfnclient.delete_stack(
                              StackName=stackName
                          )
                      stackDeleteInProgress=True
                      while stackDeleteInProgress:
                          timeNow=time.time()
                          time.sleep(amplifyPollTimeSec)
                          stackIdInfo = cfnclient.describe_stacks(
                              StackName=stackId
                          )
                          status=stackIdInfo['Stacks'][0]['StackStatus']
                          if status == 'DELETE_COMPLETE':
                              stackDeleteInProgress=False
                              print("Delete Complete")
                              result = cfnresponse.SUCCESS
                          elif status == 'DELETE_FAILED':
                              stackDeleteInProgress=False
                              print('Stack Deletion Failed')
                          elif (timeNow - startTime) > (int(selfInvokeTimeMin)*60):
                              stackDeleteInProgress=False
                              if (timeNow-event[resourceStartTime]) > (int(resourceTimeoutMin)*60):
                                  print('resource Timeout')
                              else:
                                  event[execution]  = event[execution] + 1
                                  stackDeleteInProgress=False
                                  print('self invoke')
                                  lambdaClient = boto3.client('lambda')
                                  lambdaClient.invoke(
                                      FunctionName=functionName,
                                      InvocationType='Event',
                                      Payload=bytes(json.dumps(event), encoding='utf8')
                                  )
                                  print('self invoke success')
                                  return
                  else:
                      print("success")
                      result = cfnresponse.SUCCESS
              except Exception as e:
                  print('error', e)
              cfnresponse.send(event, context, result, {})
  LambdaExecutionRoleDeployApp:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'lambda-execution-role-deploy-app-${ProjectName}'
      ManagedPolicyArns:
          - !Sub "arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement: 
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
  LambdaexecutionpolicyDeployApp:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyName: !Sub 'lambda-execution-policy-deploy-app-${ProjectName}'
      Roles: 
        - !Ref LambdaExecutionRoleDeployApp
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub
              - "arn:${AWS::Partition}:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*"
              - region: !Ref "AWS::Region"
                account: !Ref "AWS::AccountId"
                lambda: !Sub 'DeployAmplifyApp${ProjectName}'
  DeployAppCustomResource:
    DependsOn:
      - LambdaexecutionpolicyDeployApp
      - AmplifyBranch
    Type: Custom::DeployApp
    Properties:
      ServiceToken: !GetAtt LambdaDeployAmplifyApp.Arn
Outputs:
  DefaultDomain:
    Value: !Sub 
      - "https://${branch}.${domain}"
      - branch: !FindInMap [Constants, Value, BranchName]
        domain: !GetAtt AmplifyApp.DefaultDomain